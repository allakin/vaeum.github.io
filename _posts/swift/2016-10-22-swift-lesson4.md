---
layout: post
title:  "Дневник начинающего разработчика. Урок 4 работа с элементом PickerView."
categories: Swift Xcode
tags: Swift Xcode
description: "Урок 4 работа с элементом PickerView."
---

![Swift-lesson4](http://s017.radikal.ru/i435/1610/b4/f6fcf70848d3.jpg)

Всем привет!

Сегодня я расскажу как выводить выбранный элемент в **Label** с помощью **PickerView**.
Итак поехали!

Для начала создаем новый проект в **Xcode**, назовем его **Lesson4**, выбираем язык программирования
**Swift**. Выбираем место сохранения проекта.

![](http://s017.radikal.ru/i417/1610/b1/b943919fb39b.jpg)

Переходим в **Main.storyboard**, а затем в **Object Library**. В строке поиска вводим **PickerView**, после
того как библиотека отсортирует и отобразит элемент согласно введенному названию. Перетащите
элемент на экран приложения  и расположите его по середине экрана.
Укажите элементу **PickerView** горизонтальные и вертикальные ограничения(**Constraints**) для
позиционирования его на экране приложения.

![](http://s019.radikal.ru/i616/1610/5e/26128674d8a3.jpg)

А если вы не перетащили PickerView на середину экрана, то можно воспользоваться автоматическим
выравниванием согласно ограничениям, чтобы убрать оранжевые сплошные и пунктирные линии.

![](http://s017.radikal.ru/i431/1610/40/eef88bdc5394.jpg)

Т.к. по умолчанию ограничения создаются в центре экрана.

**Вы можете пойти двумя разными способами:**

1. Перенести **Constraints** на то место, где располагается элемент.
2. Перенести элемент в центр согласно **Constraints**.

**Первый вариант.**

Выделяем **PickerView** и переходим в **Resolve Auto Layout Issues.**

![](http://s017.radikal.ru/i404/1610/ae/867e90ab57f9.jpg)

В открывшемся окне, выбираем **Update Constraints.**

![](http://i069.radikal.ru/1610/e3/2ab263750411.jpg)

**Второй вариант**

Проделываем все тоже самое, что и в первом варианте, только, когда появится окно, надо
выбрать **Update Frames.**

![](http://s019.radikal.ru/i633/1610/e0/1cce7cc6bb43.jpg)

И после того, как все сделано, опять возвращаемся в **Object Library** и ищем элемент
с названием **Label.** Их нам понадобится два. Один назовем **Город**, а второй - **Название города.**

Текст у **Label** (Название города) нам нужен для того, чтобы позиционировать этот Label, позже
это уберем по желанию.

По желанию вы можете задать цвет тексту **Label**, чтобы отделить от **"Название города"** визуально.
Делается это очень просто, выделяете **Label** и переходите в **Show the Attributes inspector.**

![](http://i079.radikal.ru/1610/bc/32f38aeee0c1.jpg)

Потом находите пункт **Color** и там задаете понравившийся вам цвет.

![](http://s05.radikal.ru/i178/1610/84/2f264bd61044.jpg)

Я выбрал фиолетовый.

Теперь расставляем наши лейблы, как показано на скриншоте.

![](http://s011.radikal.ru/i316/1610/1d/e46dacb7839e.jpg)

Теперь осталось добавить **Constraints** к **Label**, тут ничего сложного, в прошлых уроках
это описывал, думаю тут не возникнет сложности.

Итак после того, как визуальная часть завершена, можно приступать к подключению и написанию кода.
Подключаем **label**(Название города) и **PickerView** в файле **ViewController.swift.**

![](http://s018.radikal.ru/i510/1610/42/b6a5f977173a.jpg)

![](http://i013.radikal.ru/1610/0e/c709f327b472.jpg)

Теперь переходим в **ViewController.swift**, к классу **ViewController** и добавляем новые протоколы
**UIPickerViewDelegate, UIPickerViewDataSource**.

```swift
class ViewController: UIViewController, UIPickerViewDelegate, UIPickerViewDataSource{
}
```

**Значение этих протоколов:**

1. UIPickerViewDelegate - Делегат реализует необходимые методы этого протокола для возврата
   высоты, ширины, заголовков строки и содержание значения для строк в каждом компоненте.
   Он также должен обеспечивать содержание для строки каждого компонента либо в виде строки
   или его вид. Как правило, делегат реализует другие необязательные методы, чтобы реагировать
   на select или deselections компонентов.
2. UIPickerViewDataSource - Протокол должен принять объект, который является связующим звеном
   между объектом UIPickerView и моделью данного приложения для этой точки зрения сборщика.
   Источник данных обеспечивает выбор режима просмотра с числом компонентов и
   количеством строк в каждом компоненте, а также для отображения данных и выбора режима
   просмотра.

После этого у нас будут ошибки, т.к. мы не реализовали методы, которые исправят эти ошибки,
и **PickerView** заработает.

Создаем переменную **cities**, в ней будет храниться информация, которая будет отображаться
в PickerView.

```swift
var cities = ["Москва", "Санкт-Петербург", "Токио", "Бостон", "Берлин", "Вашинктон", "Париж", "Милан"]
```

Теперь спускаемся ниже к методу **viewDidLoad** и пишем.

```swift
override func viewDidLoad() {
    super.viewDidLoad()
    picker.delegate = self
    picker.dataSource = self
}
```

Потом добавляем

```swift
override func viewDidLoad() {
    super.viewDidLoad()
    picker.delegate = self
    picker.dataSource = self
}
```

Потом добавляем функции.

```swift
func numberOfComponents(in pickerView: UIPickerView) -> Int {
    return 1
}

func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int {
    return cities.count
}

func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -> String? {
    return cities[row]
}

func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
    cityesLabel.text = cities[row]
}
```

**Подробнее,  что мы сделали.**

1. Функция **numberOfComponents** нужна для того, чтобы указать количество ячеек, в которых
   будет размещаться информация в PickerView. В данном случае поставил 1.
2. Функция **numberOfRowsInComponent** нужна для того, чтобы указать PickerView, где он должен
   брать информацию, которую собирается отображать. **cities.count** означает весь массив.
3. Функция **titleForRow** нужна для того, чтобы отобразить информацию на самом PickerView,
   если этого не сделать, то будут отображаться "?" и вы сами не увидите, что выбираете.
   **cities[row]** означает, что надо выбирать значение из массива.
   ![](http://s020.radikal.ru/i703/1610/d3/157aff99b2ea.jpg)
4. Функция **didSelectRow** нужна для того, чтобы вывести информацию в наш **Label**.
   ![](http://s017.radikal.ru/i440/1610/92/30a4f357f49d.jpg)

И теперь, по желанию, хотите уберите текст **"Название города"** или же можете оставить.

Запускаете приложение и оно должно работать как тут.

![](http://s011.radikal.ru/i317/1610/36/d0f9eaaa0bc4.gif)

Всем спасибо! Увидимся через неделю.


